using System.Reflection.Emit;
using System.Reflection.Metadata;
using System.Text;
using Kmse.Core.IO;
using Kmse.Core.Memory;
using Kmse.Core.Z80.Support;

namespace Kmse.Core.Z80;

public class Z80Cpu : IZ80Cpu
{
    private readonly ICpuLogger _cpuLogger;
    private int _currentCycleCount;
    private IMasterSystemIoManager _io;
    private IMasterSystemMemory _memory;
    private bool _halted;

    private const int NopCycleCount = 4;

    private Z80Register _af, _bc, _de, _hl;
    private Z80Register _afShadow, _bcShadow, _deShadow, _hlShadow;
    private Z80Register _ix, _iy;
    private Z80Register _pc, _stackPointer;
    private byte _iRegister, _rRegister;

    /// <summary>
    /// Disables interrupts from being accepted if set to False
    /// </summary>
    private bool _interruptFlipFlop1 = false;
    /// <summary>
    /// Temporary storage location for FF1 above
    /// </summary>
    private bool _interruptFlipFlop2 = false;

    private byte _interruptMode = 0;

    // TODO: In future, maybe we can combine these into a single dictionary and lookup but need to evaluate how different the handling is first
    private readonly Dictionary<byte, Instruction> _genericInstructions = new();
    private readonly Dictionary<byte, Instruction> _cbInstructions = new();
    private readonly Dictionary<byte, Instruction> _ddInstructions = new();
    private readonly Dictionary<byte, Instruction> _edInstructions = new();
    private readonly Dictionary<byte, Instruction> _fdInstructions = new();

    // TODO: Can we improve handling of logging of instructions and fetching of memory reads
    private ushort _currentAddress;
    private readonly StringBuilder _currentData = new();

    public Z80Cpu(ICpuLogger cpuLogger)
    {
        _cpuLogger = cpuLogger;
        _pc = new Z80Register();
        _af = new Z80Register();
        _bc = new Z80Register();
        _de = new Z80Register();
        _hl = new Z80Register();
        _afShadow = new Z80Register();
        _bcShadow = new Z80Register();
        _deShadow = new Z80Register();
        _hlShadow = new Z80Register();
        _ix = new Z80Register();
        _iy = new Z80Register();
        _stackPointer = new Z80Register();
        _iRegister = 0;
        _rRegister = 0;
        PopulateInstructions();
    }

    public void Initialize(IMasterSystemMemory memory, IMasterSystemIoManager io)
    {
        _memory = memory;
        _io = io;
    }

    public void Reset()
    {
        _currentCycleCount = 0;

        // Reset program counter back to start
        _pc.Word = 0x00;

        _halted = false;
        _interruptFlipFlop1 = false;
        _interruptFlipFlop2 = false;
        _interruptMode = 0;

        _iRegister = 0;
        _rRegister = 0;

        // Stack pointer starts at highest point in RAM
        // but various hardware register control writes, generally we set to 0xDFF0
        // https://www.smspower.org/Development/Stack
        _stackPointer.Word = 0xDFF0;

        _af.Word = 0x00;
        _bc.Word = 0x00;
        _de.Word = 0x00;
        _hl.Word = 0x00;

        _afShadow.Word = 0x00;
        _bcShadow.Word = 0x00;
        _deShadow.Word = 0x00;
        _hlShadow.Word = 0x00;

        _io.ClearNonMaskableInterrupt();
        _io.ClearMaskableInterrupt();
    }

    public int ExecuteNextCycle()
    {
        _currentCycleCount = 0;
        _currentAddress = 0;
        _currentData.Clear();

        if (_io.NonMaskableInterrupt)
        {
            // Handle NMI by jumping to 0x66
            ResetProgramCounter(0x66);

            // If halted then NMI starts it up again
            _halted = false;

            // Clear interrupt since serviced
            _io.ClearNonMaskableInterrupt();
            return _currentCycleCount;
        }

        if (_interruptFlipFlop1 && _io.MaskableInterrupt)
        {
            // Copy state of IFF1 into IFF2 to keep a copy and reset IFF1 so processing can continue
            _interruptFlipFlop2 = _interruptFlipFlop1;
            _io.ClearMaskableInterrupt();
            _interruptFlipFlop1 = false;

            if (_interruptMode is 0 or 1)
            {
                // The SMS hardware generates two types of interrupts: IRQs and NMIs.
                // An IRQ is a maskable interrupt which may be generated by:
                // * the VSync impulse which occurs when a frame has been rasterised, or:
                // // * a scanline counter falling below zero(see the VDP Register 10 description
                // for details)

                //For the SMS 2, Game Gear, and Genesis, the value $FF is always read from
                // the data bus, which corresponds to the instruction 'RST 38H'.
                // Basically same as mode 1

                // Mode 1, jump to address 0x0038h similar to NMI
                ResetProgramCounter(0x0038);
                return _currentCycleCount;
            }

            // Mode 2 is not used in SMS since ports don't set a byte on data bus
            //https://www.smspower.org/uploads/Development/richard.txt
            // Maybe it is used but with random values returned?
            //https://www.smspower.org/uploads/Development/smstech-20021112.txt
            _cpuLogger.LogDebug("Maskable Interrupt while in mode 2 which is not supported");
            _currentCycleCount += NopCycleCount;
            return _currentCycleCount;
        }

        if (_halted)
        {
            // NOP until interrupt
            return NopCycleCount;
        }

        // https://www.smspower.org/Development/InstructionSet
        var opCode = GetNextOperation();

        var instruction = opCode switch
        {
            0xCB => ProcessCBOpCode(),
            0xDD => ProcessDDOpCode(),
            0xFD => ProcessFDOpCode(),
            0xED => ProcessEDOpCode(),
            _ => ProcessGenericNonPrefixedOpCode(opCode)
        };

        if (instruction == null)
        {
            // Unhandled instruction, just do a NOP
            _cpuLogger.LogInstruction(_currentAddress, "Unhandled", "");
            _currentCycleCount += NopCycleCount;
            return _currentCycleCount;
        }

        instruction.Execute();
        _currentCycleCount += instruction.ClockCycles;

        // TODO: Need to improve the logging of instructions especially for two byte instructions
        _cpuLogger.LogInstruction(_currentAddress, instruction.Name, "");

        return _currentCycleCount;
    }

    private Instruction ProcessGenericNonPrefixedOpCode(byte opCode)
    {
        if (!_genericInstructions.TryGetValue(opCode, out var instruction))
        {
            _cpuLogger.LogDebug($"Unhandled instruction - {opCode:X2}");
        }

        return instruction;
    }

    private Instruction ProcessCBOpCode()
    {
        // Two byte op code, so get next part of instruction and use that to lookup instruction
        var secondOpCode = GetNextOperation();
        if (!_cbInstructions.TryGetValue(secondOpCode, out var instruction))
        {
            _cpuLogger.LogDebug($"Unhandled 0xCB instruction - {secondOpCode:X2}");
        }

        return instruction;
    }

    private Instruction ProcessDDOpCode()
    {
        // Two byte op code, so get next part of instruction and use that to lookup instruction
        var secondOpCode = GetNextOperation();
        if (!_ddInstructions.TryGetValue(secondOpCode, out var instruction))
        {
            _cpuLogger.LogDebug($"Unhandled 0xDD instruction - {secondOpCode:X2}");
        }

        return instruction;
    }

    private Instruction ProcessFDOpCode()
    {
        // Two byte op code, so get next part of instruction and use that to lookup instruction
        var secondOpCode = GetNextOperation();
        if (!_fdInstructions.TryGetValue(secondOpCode, out var instruction))
        {
            _cpuLogger.LogDebug($"Unhandled 0xFD instruction - {secondOpCode:X2}");
        }

        return instruction;
    }

    private Instruction ProcessEDOpCode()
    {
        // Two byte op code, so get next part of instruction and use that to lookup instruction
        var secondOpCode = GetNextOperation();
        if (!_edInstructions.TryGetValue(secondOpCode, out var instruction))
        {
            _cpuLogger.LogDebug($"Unhandled 0xED instruction - {secondOpCode:X2}");
        }

        return instruction;
    }

    // TODO: Split classes into core management, execution methods and instruction set

    private void PopulateInstructions()
    {
        AddGenericInstruction(0x00, "NOP", "No Operation", 4, () => { });
        AddGenericInstruction(0x76, "HALT", "Halt", 4, () => { _halted = true; });

        // Interrupt instructions
        AddGenericInstruction(0xF3, "DI", "Disable Interrupts", 4, () => { _interruptFlipFlop1 = false; _interruptFlipFlop2 = false; });
        AddGenericInstruction(0xFB, "EI", "Enable Interrupts", 4, () => { _interruptFlipFlop1 = true; _interruptFlipFlop2 = true; });
        AddDoubleByteInstruction(0xED, 0x46, "IM 0", "Set Maskable Interupt to Mode 0", 8, () => { _interruptMode = 0;});
        AddDoubleByteInstruction(0xED, 0x56, "IM 1", "Set Maskable Interupt to Mode 1", 8, () => { _interruptMode = 1; });
        AddDoubleByteInstruction(0xED, 0x5E, "IM 2", "Set Maskable Interupt to Mode 2", 8, () => { _interruptMode = 2; });
    }

    private void AddGenericInstruction(byte opCode, string name, string description, int cycles, Action handleFunc)
    {
        _genericInstructions.Add(opCode, new Instruction(opCode, name, description, cycles, handleFunc));
    }

    private void AddDoubleByteInstruction(byte prefix, byte opCode, string name, string description, int cycles, Action handleFunc)
    {
        switch (prefix)
        {
            case 0xCB: _cbInstructions.Add(opCode, new Instruction(opCode, name, description, cycles, handleFunc)); break;
            case 0xDD: _ddInstructions.Add(opCode, new Instruction(opCode, name, description, cycles, handleFunc)); break;
            case 0xED: _edInstructions.Add(opCode, new Instruction(opCode, name, description, cycles, handleFunc)); break;
            case 0xFD: _fdInstructions.Add(opCode, new Instruction(opCode, name, description, cycles, handleFunc)); break;
        }
    }

    private void SetFlag(Z80StatusFlags flags)
    {
        _af.Low |= (byte)flags;
    }

    private void ClearFlag(Z80StatusFlags flags)
    {
        _af.Low &= (byte)~flags;
    }

    private void SetClearFlagConditional(Z80StatusFlags flags, bool condition)
    {
        if (condition)
        {
            SetFlag(flags);
        }
        else
        {
            ClearFlag(flags);
        }
    }

    private bool IsFlagSet(Z80StatusFlags flags)
    {
        var currentSetFlags = (Z80StatusFlags)_af.Low & flags;
        return currentSetFlags == flags;
    }

    private byte GetNextOperation()
    {
        var data = _memory[_pc.Word];

        if (_currentAddress == 0)
        {
            _currentAddress = _pc.Word;
        }
        else
        {
            // Only set current data if reading additional information beyond command itself
            _currentData.Append($"{data:X2} ");
        }

        _cpuLogger.LogMemoryRead(_pc.Word, data);

        _pc.Word++;
        return data;
    }

    private void ResetProgramCounter(ushort address)
    {
        // Four cycles to fetch current Pc register
        _currentCycleCount += 4;

        // Storing PC in Stack so can resume later
        PushRegisterToStack(_pc);

        // Update PC to execute from new address
        _pc.Word = address;

        // 1 cycle to jump?
        _currentCycleCount += 1;
    }

    private void PushRegisterToStack(Z80Register register)
    {
        var currentPointer = _stackPointer.Word;
        _memory[--currentPointer] = register.High;
        _memory[--currentPointer] = register.Low;
        _stackPointer.Word = currentPointer;

        // 4 cycles to write to memory and 2 cycles total to decrement stack pointer (decremented twice)
        _currentCycleCount += 2 + 4;
    }

    private class Instruction
    {
        public Instruction(byte opCode, string name, string description, int cycles, Action handleMethod)
        {
            OpCode = opCode;
            Name = name;
            Description = description;
            ClockCycles = cycles;
            _handleMethod = handleMethod;
        }

        private readonly Action _handleMethod;

        public byte OpCode { get; }
        public string Name { get; }
        public string Description { get; }
        public int ClockCycles { get; }

        public void Execute()
        {
            _handleMethod();
        }
    }
}